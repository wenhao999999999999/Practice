# LeetCode 题型总结与通用解法（基于本仓库代码）

本文汇总本仓库 `LeetCode/LeetCode` 目录下各类题型的常见题干模式、解题套路、通用框架与思考路径，并为每一类给出一个代表性问题的详细讲解（均与仓库代码保持一致，便于对照复盘）。

---

## 数组（快慢指针 / 频次统计 / 其他）

- 题干常见：
  - 原地删除/压缩（如“原地删除重复元素、保留前 k 次”）。
  - 旋转/重排数组（如“向右轮转 k 位”）。
  - 众数/出现次数统计（哈希或摩尔投票）。
- 一般套路：
  - 有序数组的“原地”改写：快慢指针维护写入边界；必要时再配合计数器限制次数。
  - 旋转操作：整体反转 + 局部反转（或环状替换）。
  - 众数：哈希计数或摩尔投票（候选值 + 计数增减）。
- 解题框架：
  - 快慢指针：`slow` 维护已写区间的边界；`fast` 逐一扫描；按规则决策是否写入 `nums[slow] = nums[fast]`。
  - 摩尔投票：计数为 0 切换候选；相同 +1，不同 -1；最终候选即答案（题目保证存在）。
- 代表题目：删除有序数组中的重复项 II（每个元素最多保留两次）
  - 思路：
    - 维护 `slow` 为写指针、`fast` 为读指针，并用 `count` 记录当前值已写入次数；
    - 新值与 `nums[slow]` 不等时直接写入；相等时仅 `count < 2` 才写入；
    - 当 `fast` 移动到新值时重置 `count`。
  - 易错点：先递增 `slow` 再赋值；遇到新值要重置 `count`；返回长度为 `slow + 1`。
  - 代码参考：`LeetCode/LeetCode/array.cpp` 中“删除有序数组中的重复项 II”。

---

## 滑动窗口（子串 / 子数组）

- 题干常见：
  - 最短/最长满足条件的子数组/子串（和、种类、覆盖、频次对齐等）。
  - 子串拼接、异位词窗口、覆盖子串等。
- 一般套路：
  - 双指针维护 `[left, right)`；右扩更新窗口状态，左收直到恢复不违规；在合适时机更新答案。
  - 用计数器、哈希表或窗口内和来判断窗口合法性/完成度。
- 解题框架：
  - 初始化 `left=right=0` 和窗口状态；
  - 外层 while 右扩；内层 while 在“需要收缩”时左收；
  - 在每次扩张/收缩后根据题意更新答案。
- 代表题目：长度最小的子数组（和至少为 target）
  - 思路：
    - 右扩累计 `sum`；当 `sum >= target` 时尽量左收（缩短长度）并更新最优答案；
    - 若最终没有满足条件，返回 0。
  - 关键点：窗口内仅用当前和即可；`res` 初值设为 `INT_MAX`，最终判空再置 0。
  - 代码参考：
    - `LeetCode/LeetCode/slidingwindow.cpp`（滑动窗口模板与实现）
    - `LeetCode/LeetCode/array.cpp` 末段含同题实现与模板笔记。

---

## 二分查找（精确值 / 左右边界）

- 题干常见：
  - 有序数组中查找目标值位置；
  - 查找左/右边界（第一/最后一次出现位置或插入位置）。
- 一般套路：
  - 用闭区间 `while (left <= right)`；
  - 比较 `nums[mid]` 与 `target`：相等时是否收缩到左/右继续逼近边界取决于题意；
  - 边界检查防止越界，索引返回要与题意对齐。
- 解题框架：
  - 精确值：相等直接返回；否则标准左右边界收缩；
  - 左边界：相等时收缩右侧 `right = mid - 1`；循环结束检查 `left` 合法再判值。
- 代表题目：搜索插入位置（返回应插入的最左索引）
  - 思路：对“左边界”模板实现，找第一个 `>= target` 的位置，若未命中则返回 `left`。
  - 代码参考：`LeetCode/LeetCode/binarysearch.cpp`。

---

## 动态规划（记忆化 / 表格法）

- 题干常见：
  - 求最优值（最少/最多/最优路径/最优个数）；
  - 子序列/路径计数；
  - 区间/序列的最优划分。
- 一般套路：
  - 明确“状态”和“选择”，写出状态转移；
  - 有重叠子问题则记忆化或自底向上；
  - 注意 base case 与无解标记（如 `-1`）。
- 解题框架：
  - 记忆化搜索：`dp(state) = min/max{ dp(next_state)+cost }`，数组/哈希记忆；
  - 表格法：定义 `dp[i][...]` 含义与初始化，按拓扑顺序推导。
- 代表题目：零钱兑换（最少硬币数）
  - 状态定义：`dp[amount]` 为凑成 `amount` 的最少硬币数；
  - 转移：枚举硬币 `coin`，`dp[amount] = min(dp[amount], dp[amount-coin] + 1)`；
  - 实现细节：记忆化返回 `-1` 表示无解；注意 `INT_MAX` 溢出与初值；
  - 代码参考：`LeetCode/LeetCode/dynamicPlanning.cpp`（记忆化实现）。

---

## 贪心（局部最优推全局最优）

- 题干常见：
  - 能否到达/最少步数/最少资源等覆盖问题；
  - 区间调度、合并、装载等优化。
- 一般套路：
  - 识别单调性或“最优子结构 + 贪心选择性质”；
  - 每步选“当前最有潜力”的决策，使全局达最优或可证最优。
- 解题框架：
  - 跳跃类：维护当前一步能覆盖的最远边界 `end` 与下一步潜在最远 `farthest`；到边界就步数 +1 并更新边界。
- 代表题目：跳跃游戏 II（最少跳数）
  - 思路：线性扫描，区间 `[i, end]` 内更新 `farthest = max(farthest, i + nums[i])`；当 `i == end` 说明需要多跳一步并把 `end = farthest`；当 `end` 覆盖末尾则返回步数。
  - 代码参考：`LeetCode/LeetCode/greedy.cpp`。

---

## 哈希表（计数 / 去重 / 映射）

- 题干常见：
  - 频次统计、是否可构成、最长连续/不重复；
  - O(1) 插入/删除/取随机（数组 + 哈希）。
- 一般套路：
  - `unordered_map/set` 做计数或存在性；
  - 巧用“双射”（双向映射）保证一一对应；
  - 结构设计题：数组存元素、哈希存索引，实现 O(1) 操作。
- 解题框架：
  - 去重/是否存在：先转集合；
  - 最长连续序列：只从“起点”开始向右数（`num-1` 不在集合）；整体 O(n)。
- 代表题目：最长连续序列
  - 思路：将数组放入 `unordered_set`；遍历集合，对每个“起点”累加连续长度并维护答案。
  - 代码参考：`LeetCode/LeetCode/hashmap.cpp`。

---

## 区间问题（排序 + 扫描/合并）

- 题干常见：
  - 插入新区间并与已有有序不交叠区间合并；
  - 合并重叠区间、摘要输出连续段。
- 一般套路：
  - 先处理在新区间左侧且不相交的区间；
  - 合并所有与新区间重叠的区间（按左右端点取 min/max）；
  - 最后追加右侧剩余区间。
- 解题框架：
  - 双指针/索引遍历 + 条件判断合并；
  - 保持结果递增有序。
- 代表题目：插入区间
  - 思路：三段式处理（左侧不重叠；中间合并；右侧不重叠），一次扫描完成。
  - 代码参考：`LeetCode/LeetCode/interval.cpp`。

---

## 矩阵（原地修改 / 邻域扫描）

- 题干常见：
  - 原地置零、原地更新下一状态（生命游戏）；
  - 方向数组走格/邻域统计。
- 一般套路：
  - 置零：先记录需置零的行列，再二次遍历置零（或用首行首列作为标记位节省空间）。
  - 生命游戏：两位编码（低位存旧态，高位暂存新态），最后整体右移一位。
- 解题框架：
  - 双层遍历 + 标记结构（集合/布尔矩阵/位编码）；
  - 统一“同时更新”。
- 代表题目：矩阵置零
  - 思路：第一次遍历收集零的行列；第二次遍历命中行列即置零。
  - 代码参考：`LeetCode/LeetCode/matrix.cpp`。

---

## 图与 BFS（最短步数 / 状态图最短路）

- 题干常见：
  - 最少变换步数、最短路径、层序最短步；
  - 状态图（字符串/棋盘）的相邻状态扩展。
- 一般套路：
  - 队列层序遍历；`visited` 去重；按层计数 `steps`；
  - 定义邻居生成器 `getNeighbors`/`getNext`；
  - 命中目标提前返回当前层步数。
- 解题框架：
  - `queue` 初始状态入队；循环弹层、扩邻、标记访问；步数层次+1。
- 代表题目：打开转盘锁
  - 思路：
    - 死亡状态放入集合排除；初始“0000”入队；
    - 生成每个位置 +1/-1 的相邻状态；
    - BFS 扩展，遇到目标立刻返回层数。
  - 代码参考：`LeetCode/LeetCode/BFS.cpp`。

---

## 图与 DFS/回溯（遍历 / 克隆 / 计数）

- 题干常见：
  - 克隆图、所有路径、网格岛屿数（连通块 DFS）。
- 一般套路：
  - DFS：显式/隐式图递归；用 `visited` 防回头；
  - 网格：遇陆地计数并 DFS 淹没相邻；先处理边界可排除“非封闭岛”。
- 解题框架：
  - 递归前/后序位置处理状态（标记访问、路径数组 push/pop）。
- 代表题目：被围绕的区域
  - 思路：
    - 逆向思维：先从边界出发将与边界连通的 O 标记为 A；
    - 再遍历矩阵将剩余 O 置为 X，A 还原为 O。
  - 代码参考：`LeetCode/LeetCode/graph.cpp`（DFS 与 BFS 两版）。

---

## 回溯（子集/排列/组合）

- 题干常见：
  - 所有全排列/组合/子集；
  - 带重复元素去重。
- 一般套路：
  - 路径 + 选择列表 + 结束条件；
  - 可重去重：先排序；同层去重用“前一个相同元素必须已被使用”。
- 解题框架：
  - `path.push` 做选择 → 递归 → `path.pop` 撤销选择；
  - 结束条件：`path.size()` 达到目标长度或搜索完毕。
- 代表题目：全排列 II（含重复元素）
  - 思路：
    - 先排序；用 `visited` 数组标记使用；
    - 同层去重：`if (i>0 && nums[i]==nums[i-1] && !visited[i-1]) continue;`
  - 代码参考：`LeetCode/LeetCode/backTracking.cpp`。

---

## 链表（快慢指针 / 分治合并）

- 题干常见：
  - 检环/入环点、相交、删除倒数第 N 个、合并 K 个链表。
- 一般套路：
  - 快慢指针判环；相遇后一头一尾再走相遇即入环点；
  - 双指针间隔 k 步删除倒数第 N；
  - 合并 K 链表：分治或优先队列。
- 解题框架：
  - 判环 II：第一阶段找相遇；第二阶段一个从头、一个从相遇点同步走到入环点。
- 代表题目：环形链表 II
  - 代码参考：`LeetCode/LeetCode/linkedList.cpp`。

---

## 栈与单调栈（表达式 / 配对 / Next Greater）

- 题干常见：
  - 括号匹配、逆波兰表达式、路径化简；
  - 下一个更大/更小元素（单调栈）。
- 一般套路：
  - 括号/表达式：遇数字入栈、遇操作弹两数运算再入栈；
  - 单调栈：从右往左维护单调性，弹出不可能成为答案的元素。
- 解题框架：
  - 单调栈：`for i= n-1..0: while(!empty && top<=nums[i]) pop; res[i]= empty?-1:top; push(nums[i])`。
- 代表题目：下一个更大元素（通用模板）
  - 代码参考：`LeetCode/LeetCode/classicExercisesofStacks.cpp`（文件末尾 `calculateGreaterElement`）。

---

## 队列与循环队列（滑窗计数 / 结构设计）

- 题干常见：
  - 最近请求次数（窗口内请求数）；
  - 设计循环队列/双端队列。
- 一般套路：
  - 时间窗口：队列入新时间，弹出窗口外的旧时间；
  - 循环数组：两个指针 `first/last` + 动态扩容/定长约束。
- 解题框架：
  - RecentCounter：入队 `t`，弹出 `< t-3000`，返回 `queue.size()`。
- 代表题目：最近请求次数 / 设计循环队列
  - 代码参考：`LeetCode/LeetCode/classicExercisesofQueue.cpp`。

---

## 二叉树（遍历与分解）

- 题干常见：
  - 根到叶路径、路径和、右视图、最小字符串等。
- 一般套路：
  - 遍历型：前中后序收集结果（回溯维护 path）；
  - 分解型：函数返回需要的“子树信息”，父问题由子问题合并而来。
- 解题框架：
  - 路径题：前序 `push`，到叶子收集结果，返回前 `pop`；
  - 层序：队列逐层，按需求挑选每层元素（如右视图取每层第一个/最后一个）。
- 代表题目：二叉树的所有路径
  - 思路：DFS 记录路径，到叶子将 `path` 拼接为字符串加入结果，回溯弹出。
  - 代码参考：`LeetCode/LeetCode/binarytree.cpp`。

---

## 代表题详细推导示例（精选）

以下选取三道仓内代表题，完整走一遍“读题 → 建模 → 框架 → 细节 → 正确性”的思考过程。

1) 滑动窗口：长度最小的子数组（目标和 ≥ target）
- 读题与建模：
  - 连续子数组，且元素为正整数；目标是最短长度，使窗口内元素和 ≥ target。
- 框架选择：典型固定方向窗口题；右扩增加和、左收尽量短。
- 状态与收缩条件：
  - 维护 `sum` 为窗口和；当 `sum >= target` 时可以左收（缩短长度）。
- 细节：
  - 先右扩累加，再在 while 里更新答案并左收；结果初值 `INT_MAX`，最终判空置 0。

2) 动态规划：零钱兑换
- 读题：硬币无限，最少个数凑出 `amount`；可能无解。
- 状态设计：`dp[x]` 为凑出金额 x 的最少硬币数。
- 转移：`dp[x] = min(dp[x], dp[x-coin] + 1)`，对所有可用 `coin`；
- 初值与无解：`dp[0]=0`；无解用 `-1` 或 `INF` 判断；记忆化需缓存 `-666` 表示“未计算”。
- 正确性：最优子结构明显；重叠子问题通过记忆化避免指数级展开。

3) 贪心：跳跃游戏 II
- 读题：每个位置给出最远跳力，问到末尾最少跳数；保证可达。
- 观察：每跳一步都应让“覆盖边界”尽量靠右（潜力最大）。
- 框架：线性扫描维护两个变量：
  - `farthest` 当前步能延伸到的最远位置；
  - `end` 当前已使用步数能覆盖的最右边界；当 `i == end` 必须多跳一步并更新 `end=farthest`。
- 细节：只遍历到 `n-2`，因为最后一步落在末尾即可。

---

## 使用建议

- 看题先归类：确定是“窗口/双指针/二分/DP/贪心/图/树/栈队列/区间”。
- 套模板前先想：状态/选择/约束/边界（多写注释，少踩细节坑）。
- 先写可 AC 的朴素解，再优化（如哈希、前缀、双指针、贪心、DP）。
- 结合本仓示例代码对照练习与复盘，形成自己的“题型—套路—模板—清单”。

以上内容对应的具体实现可在本仓 `LeetCode/LeetCode` 各文件中查阅与运行验证。

